* Google Tech Talk
** Language Affecting Architecture

*** What is Architecture?
    - It's very hard to back out the theory of the program if you didn't write it or work with those who did.
    - Higher level languages make it easier to encode the theory of the program so others can back out.
    - Naur: when you develop a program, you are developing a theory of how the program works.
    - Patterns. Christopher Alexander (building architect) theories got applied in software.
    - To what extent are the pattern languages affected by the implementation languages?
**** What are patterns? From Christopher Alexander
     - Patterns are built to resolve forces.
     - e.g., human preferences
       - People like light, so rooms with natural sunlight are preferred. Two light source rooms.
     - Cultural things.
**** Software forces
     - Typically a lot of it is just math
       - Big O complexity
     - Software patterns are built by people who "live in software"
     - I.e., the developers who have to deal with it day to day
       - Not for users.
     - All this stuff is put into a pattern language
     - Need a core that resolves all the forces
**** Patterns as they relate to languages
     - The universe of tools is already software.
       - Creates the universe in which you live
       - And creates the forces that you deal with
**** Sapir Whorf
     - Yeah yeah, I know about it already. (Human) languages influence the way you think.

** Java vs Lisp Example
*** Visitor Pattern in Java
    - Multiple dispatch via walking AST of objects.
    - Different operations on different node types. The "double dispatch" is the essence of it.
    - Normal polymorphic dispatch - interface Priceable, and other classes implement it.
    - It's not overloading - it's not about naming things the same, but binding it together using the interface.
    - Hand coded dispatching would be just a case statement in the function, casing on types. Visitor is supposed to solve this.
    - Hard to add new classes
    - The result is kind of like rolling your own inheritance to handle double dispatch.
*** Same Thing in Common Lisp
    - Idea of generic functions.
    - Lisp OO started by porting back smalltalk features, especially message passing/dispatch.
    - Lisp generalized single dispatch into multiple dispatch. This got into CLOS
    - define variadic function, and can dispatch on any of the required args.
    - Methods don't belong to classes anymore.
    - Instead define classes as just data, generics are functions that could in theory be applied anything.
    - Then the methods are specific implementations of generics for specific classes.
    - True multiple dispatch, and only one mechanism. Multiple dispatch and multiple inheritance in CL
    - This generalization allowed crazy things.
    - Main method, and methods that run before, during, after, etc. (Ch 23 - 24)
    - To manage conflicts, there's a canonical algorithm for sorting the priority of methods.

** Error Handling in Different Languages

*** Invariants
    - Pre cond, post cond, class invariance
    - True before, true after
    - Pre condition can be divided into
      - provable by static analysis (the formal pre condition classic notion)
      - Or not (i.e., random shit that can't be logically handled, like asynchronocity) and other corner cases
    - That's what error handling is for.
    - If you satisfy your formal pre but can't your posts, should "handle errors cleanly", i.e. code should fail cleanly. Then deal with lower level failures.
    - C style is return 0 or 1 etc
    - Python/Java style is exception handling. Satisfy the base requirement - if you call something that fails, you must either handle it or fail yourself.
    - Sometimes recover from stack unwinds, but mostly not, most of the time you lost the state.

*** Common Lisp method
    - Traditionally, signal at the bottom, handle at the top.
    - CL - we have signal, but don't unwind.
      - Let signal go up the stack, but higher on the stack can be handled.
      - There's a restart that can be established between, unwind to restart and then go forward.

**** Example: Log analyzer
     - log-analyzer -> analyze-log function -> parse-log-file -> parse log entry
     - Entry parser can recognize failures, but may not be the appropriate function to handle the error
     - Could have a fatal error, or skip it, or apply some heuristic.
       
***** Java Handling
      - Java would throw at the bottom, propagate signal up to the top level app, which knows the policy.
      - However in propagation, the stack unwinds and state is lost, so lose the ability to do the right thing.

***** Common Lisp version
      - Error signalled, no unwind.
      - Signal moves up, to find the right handler.
      - low level parser can give possible strategies to the handler.
      - Top level handler catches signal and looks for e.g. skip entry restart.
      - Invokes restart, and the low level parser skips it and moves on.
      - Typically used for error handling, but can be used for communicating up and down the stack

** Macros
   - Could add the above features in CL, with the same syntax as it is now.
   - In Java, could add the same stuff (Turing Complete), but there's no way to hide it. Can't change the syntax

*** deftest example (from book)
    - done using macro expansion, expands to something pretty big
    - saves lots of work

*** Macro differences from functions
    - Compile time expansion.
    - Can use arbitrary syntax, can write it nicely.

* Practical Common Lisp Book

** Chapter 2 - REPL
   - load using ~(load "hello.lisp")~
   - ~(compile-file "hello.lisp")~
   - ~(load (compile-file "hello.lisp"))~
   - .fasl files for compiled versions

** Chapter 3 - DB Example
   - ~(list :a 1 :b 2 :c 3)~ for property list or plist
     - Unfortunately plists are actually lists and not hashes.
   - ~(getf plist :prop)~ returns the value associated with ~:prop~
   - ~(defvar *db* nil)~ - the ~*name*~ convention is for global vars
   - ~(push x l)~ destructively prepends ~x~ to ~l~.
   - ~(dolist (item list) body)~ - [body for each item in list]
   - ~(format stream fmt_str obj)~ - stream=t implies stdout
     - there's a lot going on with format in fmt_str; there's a whole sub language
       that describes how to format.
     - ~*query-io*~ is another identifier for a stream.
     - sometimes ~(force-output stream)~ is needed to "flush the buffer" i guess
     - ~(read-line stream)~ works as ~(read-line *query-io*)~
   - ~(parse-integer int_str)~; ~(parse-integer int_str :junk-allowed t)~
   - ~(y-or-n-p prompt_str)~ automatically reads yes or no into boolean.
   - ~(loop)~ is introduced here but not elaborated. I am not particularly
     interested in exploring the details of it either.
   - ~(with-open-file)~ ~(with-standard-io-syntax)~ used in saving the database.
     These apparently emit lisp readable formats, so that one can read it in later
   - Example in function form:
     #+BEGIN_SRC lisp
       (defun load-db (filename)
         (with-open-file (in filename)
           (with-standard-io-syntax
             (setf *db* (read in)))))
     #+END_SRC
   - read from stream in. ~with-standard-io-syntax~ makes the read compatible.
   - "The SETF macro is Common Lisp's main assignment operator.
     It sets its first argument to the result of evaluating its second argument."
   - ~(remove-if-not fn list)~ is basically "filter", not destructive. ~(evenp)~ tests for even
   - ~(defun foo (&key a b c) body)~ <=> ~(foo :a 2 ...)~
     - If you don't pass an arg explicitly, then it defaults to nil
     - However you can set default args as well as a "supplied-p" param
     - Example: ~z(defun foo (&key a (b 20) (c 30 c-p)) (list a b c c-p))~
       where ~b~ defaults to ~20~, ~c~ defaults to ~30~ and ~c-p~ returns ~nil~ if no arg
       passed to ~c~ directly.
   - IMPORTANT - a GREAT macro example here: ~(defmacro backwards (expr) (reverse expr))~
     - ~(backwards ("hello, world" t format))~ => ~hello, world NIL~
     - similarly, ~(backwards (1 2 +))~ => ~(+ 2 1)~ => ~3~
     - This really demonstrates the power of macros in a simple but easy to understand way.
     - The expr passed in is treated as data, so you can use all manner of list traversal
       hackery to make your way through the list and transform it.

** Chapter 4 - Syntax and Semantics
   - LISP has a reader and an evaluator.
     - Legal input to the reader is basically s-expressions plus a few extensions
     - On the other hand, the evaluator takes only legal Lisp-forms,
       i.e., ~(symbol ...)~.
   - Macro evaluation - function taking S expressions as args, and returning a Lisp form.
     - The args are passed to the function, and then the returned form (the expansion)
       is evaluated according to normal rules.
     - Distinguish between what happens at REPL vs compiling.
       - At the REPL, the macro is expanded and the resulting full expr is eval'd immediately.
       - On the other hand, when compiling, macros are recursively expanded until there
         are no macro forms left (only funcall and specials). This is then compiled and loaded.
     - Key insight, as above - macro args don't need to be list forms, only valid S-expressions
   - use = to compare numbers, char= to compare characters.
   - There are four "generic" equality predicates.
     - EQ => object identity. No clear behavior for numbers ofr characters, e.g. ~(eq 3 3)~
       and ~(eq x x)~ if ~(value x)~ => number or character. Seems really dangerous to use.
     - EQL => object identity + numeric and character value identity, if type is same.
       e.g. ~(eql 1 1)~ => t, ~(eql 1 1.0)~ => ~nil~
       - book always uses EQL
     - EQUAL is more generic - EQL, but also works on lists, e.g., lists are EQUAL if
       their content and structure are EQUAL. Strings are EQUAL if they have same chars.
     - EQUALP is like EQUAL except numbers are EQUALP if they represent
       the same mathematical value. ~(EQUALP 1 1.0)~ => ~t~

** Chapter 5 - Functions
   - ~(defun name (args*) "doc string" body*)~
   - Many people use -> in names to denote conversion functions
     ala ~string->widget~
   - ~(documentation 'fun_name 'function)~
   - The last expression gives the return value.
     - Alternatively can use ~(return-from)~
   - Arg types include required, optional, multiple, keyword
     - Required is obvious
     - ~&optional~ - required are bound first, then any remaining are bound to
       the optional args, with any leftovers bound to ~nil~
       - These can also use default and ~supplied-p~ like kw did in chapter 3
     - Multiple args are specified with ~&rest~. Args after required and
       optional are given to the rest param as a list.
     - Finally we get to kwargs. These must be specified after the other
       3 types. Can be specified in any order so long as the keyword is
       given.
       - Can also name the keyword arg differently from the kw itself.
       - Replace the keyword with a list of the kw and the new arg name
         as in ~(:box 0) => ((:box b) 0)~
   - Mixing types can be dangerous. Must be used in the above specified order.
     - req + * is pretty safe
     - optional + rest is also pretty safe.
     - key + (optional | rest) is dangerous.
       - The kw tokens take up the optional slots.
       - rest receives the whole param list including the kw tokens
   - ~(return-from block_name value)~ where the block name is typically
     the name of the function due to the nature of ~defun~ as a macro
   - The special operator ~FUNCTION~ gets a function object. Note that ~#'~
     is just syntactic sugar for ~FUNCTION~
   - To call a function passed in as an arg, we can use ~(funcall f arg1 arg2 ...)~
     but this requires a fixed number of arguments.
   - To get around this, you can use ~apply~, which accepts a function as the
     first arg, any number of loose arguments, but last arg must be a list.


** Chapter 6 - Variables
   - Some pretty straightforward stuff about binding variables in functions.
     Also goes over lexical vs dynamic scope and ~let~.
   - ~(dotimes (x 10) ...)~ binds a value to ~x~ starting from 0 and counting
     up to ~10-1~ in this case.
   - ~let*~ lets you bind variables in a sort of imperative style where later
     variables can refer to previous ones.
   - Introduces closures and lexical scope. I know this already. Just to remind myself though:
     the closure closes around the binding, not the value. So we can increment a variable in a closure.
   - ~defvar~ and ~defparameter~ create global variables and can also take doc strings.
     ~defparameter~ will assign no matter what, ~defvar~ only if variable undefined.
   - Dynamic variables exist for for the /duration/ of the binding form, not for the lexical code
     block of it, and when they exist they're effectively globals. So they're basically temp globals.
     Instead of the innermost binding having precedence, the most /recent/ binding has precedence.
     The technical term is the /extent/ of the dynamic var, thus extent and scope are "two complementary
     notions".
   - An easy way to use dynamic variables is to use let on a global. The two ~def~ forms above
     will automatically declare the variables as /special/. Locally special is available, but rarely
     used. One must declare a name special. ~declare, special, locally~
   - ~defconstant~ has global effect and same form as the other two ~def~s, the resulting name
     cannot be rebound or used a fun param. Convention dictates using ~+~ pre and post for the name.
   - Constants can be rebound later, but the results aren't defined, thus it is not good practice to
     use constants unless the name will really truly be constant.
   - To assign new values to a binding, can use ~(setf place value)~. ~setf~ returns the value it
     just bound, so it can be nested. Also, it can be used with a list of pairs as in e.g.
     ~(setf a 10 b 20)~.
   - Arrays, hashes, and other slot type functions can be used with ~setf~ e.g. ~(setf (aref a 10) 20)~.
   - A few more macros ~(incf x)~, ~(decf x)~, ~(incf x 10)~. Increment and decrement operators. These
     macros protect against double evaluation as well.
   - More variable stuff: ~push, pop, popnew, rotatef, shiftf~
     
** Chapter 7 - Macros
